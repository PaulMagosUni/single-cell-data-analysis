---
title: Clustering and differential expression analysis using COTAN
---


```{r, output=FALSE, warning=FALSE}
library(COTAN)
library(Seurat)
library(tibble)
library(ggplot2)
library(zeallot)
options(parallelly.fork.enable = TRUE)
source("../../libraries/utils.R")

dataset_name = 'PBMC'
DATASET_PATH = "../../dataset/"
inDataDir = paste(DATASET_PATH, dataset_name, '-Filtered/', sep='')
OUT_LOGGING_DIR = paste("../../results/", dataset_name, '/COTAN/', sep='')
OUT_DEFAULT_DIR = paste("../../results/", dataset_name, '/COTAN/default/', sep='')
OUT_CELLTYPIST_DIR = paste("../../results/", dataset_name, '/COTAN/celltypist/', sep='')
OUT_PROTEIN_DIR = paste("../../results/", dataset_name, '/COTAN/protein/', sep='')
if (!dir.exists(OUT_DEFAULT_DIR)) {
  dir.create(OUT_DEFAULT_DIR, recursive = TRUE)
}
if (!dir.exists(OUT_CELLTYPIST_DIR)) {
  dir.create(OUT_CELLTYPIST_DIR, recursive = TRUE)
}
if (!dir.exists(OUT_PROTEIN_DIR)) {
  dir.create(OUT_PROTEIN_DIR, recursive = TRUE)
}
if (!dir.exists(OUT_LOGGING_DIR)) {
  dir.create(OUT_LOGGING_DIR, recursive = TRUE)
}

N_CLUSTERS_CELLTYPIST = fromJSON(file=paste('../../dataset/', dataset_name, '-Filtered/raw/nclusters.json', sep=''))$nclusters
N_CLUSTERS_PROTEIN = fromJSON(file=paste('../../dataset/', dataset_name, '-Filtered/10x/nclusters.json', sep=''))$nclusters

setLoggingLevel(2)
setLoggingFile(file.path(OUT_LOGGING_DIR, paste(dataset_name, "_analysis.log", sep='')))
```

Data loading

```{r, echo=TRUE, eval=FALSE}
PBMC <- readRDS(file = file.path(inDataDir, paste0(dataset_name, ".cotan.RDS")))
```

```{r, echo=FALSE, EVAL=TRUE}
PBMC2 <- readRDS(file = file.path(OUT_DEFAULT_DIR, paste0(dataset_name, ".cotan.RDS")))
```

Calculate genesâ€™ COEX

```{r, echo=TRUE, eval=FALSE}
PBMC <- proceedToCoex(
  PBMC,
  calcCoex = TRUE,
  cores = 10,
  saveObj = TRUE,
  outDir = OUT_DEFAULT_DIR
)
```

```{r, echo=TRUE, eval=TRUE}
gdiData <- calculateGDI(PBMC)
genesToLabel <- head(
  rownames(gdiData[order(gdiData[["GDI"]], decreasing = TRUE), ]),
  n = 50L
)
sort(genesToLabel)
```

```{r, echo=TRUE, eval=TRUE}
gdiData[genesToLabel[[50L]], "GDI"]
```

```{r, echo=TRUE, eval=TRUE}
gdiPlot <- GDIPlot(
  PBMC,
  GDIIn = gdiData,
  GDIThreshold = 1.4,
  genes = list("Top 10 GDI genes" = genesToLabel[1L:10L])
)
plot(gdiPlot)
```

Clustering

```{r, echo=TRUE, eval=FALSE}
c(splitClusters, splitCoexDF) %<-%
  cellsUniformClustering(
    PBMC,
    GDIThreshold = 1.4,
    cores = 13,
    saveObj = TRUE,
    outDir = OUT_DEFAULT_DIR
  )

PBMC <- addClusterization(
  PBMC,
  clName = "split",
  clusters = splitClusters,
  coexDF = splitCoexDF,
  override = TRUE
)
```

```{r, echo=TRUE, eval=TRUE}
splitClusters <- getClusterizationData(PBMC, clName = "split")[[1]]
table(splitClusters)
```

Merge uniform clusters

```{r, echo=TRUE, eval=FALSE}
c(mergedClusters, mergedCoexDF) %<-%
  mergeUniformCellsClusters(PBMC, clusters = splitClusters,
                            GDIThreshold = 1.4, cores = 13,
                            saveObj = TRUE, outDir = OUT_DEFAULT_DIR)

PBMC <- addClusterization(PBMC, clName = "merged",
                             clusters = mergedClusters,
                             coexDF = mergedCoexDF,
                             override = TRUE)
```

```{r, echo=TRUE, eval=TRUE}
mergedClusters <- getClusterizationData(PBMC, clName = "merged")[[1]]
clusters_sizes = table(mergedClusters)
cat(paste('Number of clusters found: ', nrows(clusters_sizes), sep=''))
```

Save the clustering result

```{r, echo=TRUE, eval=FALSE}
final_clusters = mergedClusters
final_clusters_name = "merged"
cluster = as.data.frame(final_clusters)
colnames(cluster)[colnames(cluster) == deparse(substitute(final_clusters))] <- "cluster"
cluster$cluster = match(cluster$cluster, levels(final_clusters))
cluster$cell = rownames(cluster)
rownames(cluster) = c(1:nrow(cluster))
write_clustering(OUT_DEFAULT_DIR, cluster, "cell", "cluster")
```

Differential expression

```{r, echo=TRUE, eval=FALSE}
coexDF <- DEAOnClusters(PBMC, clusters = final_clusters)
PBMC <- addClusterizationCoex(PBMC, clName = final_clusters_name,
                             coexDF = coexDF)
```

```{r, echo=TRUE, eval=FALSE}
saveRDS(PBMC, file = file.path(OUT_DEFAULT_DIR, paste0(dataset_name, ".cotan.RDS")))
```

Save markers

```{r, echo=TRUE, eval=FALSE}
write_markers = function(ourDir, clusters, coex, TOP_MARKER_NUM, decreasing) {
    markers = data.frame()

    for (cluster_id in (levels(clusters))) {
        cluster_markers = data.frame()
        pv = coex[, cluster_id]
        names(pv) = rownames(coex)
        sorted_pv = sort(pv, decreasing = decreasing)
        cluster_markers = data.frame(gene = names(sorted_pv)[1:TOP_MARKER_NUM],
                                    cluster = match(cluster_id, levels(clusters)),
                                    rank = 1:TOP_MARKER_NUM)
        markers = rbind(markers, cluster_markers)
    }
    colnames(markers) = c("gene","cluster","rank")

    write.csv(markers, "markers.csv", row.names = FALSE)
}

TOP_MARKER_NUM = 500

numCells <- getNumCells(PBMC)
pvals <- pValueFromDEA(coexDF, numCells)

write_markers(OUT_DEFAULT_DIR, final_clusters, pvals, TOP_MARKER_NUM, FALSE)
```

Merge clusters according to celltypist

```{r, echo=TRUE, eval=FALSE}
# get ids of clusters bigger than 40 cells
mapping = read.csv(paste('../../dataset/', dataset_name, '-Filtered/raw/celltypist_mapping.csv', sep=''))
counts = read.csv(paste('../../dataset/', dataset_name, '-Filtered/raw/celltypist_annotation_counts.csv', sep=''))

mapping_counts = merge(mapping, counts, by.x = "go", by.y = "cluster.ids")
mapping_counts = subset(mapping_counts, count > 40)
clusters_ids_to_keep = mapping_counts$id

# get barcodes of cells in clusters bigger than 40 cells
celltypist_labels = read.csv(paste('../../dataset/', dataset_name, '-Filtered/raw/celltypist_labels.csv', sep=''))
celltypist_labels = subset(celltypist_labels, cluster.ids %in% clusters_ids_to_keep)
barcodes_to_keep = celltypist_labels$cell

# keep only cells in clusters bigger than 40 cells
barcodes_to_drop = getCells(PBMC)[!getCells(PBMC) %in% barcodes_to_keep]
PBMC_celltypist <- dropGenesCells(PBMC, cells = barcodes_to_drop)

range_upper = 3
range_lower = 0

repeat{
  resolution = (range_upper + range_lower) / 2
  cat(paste("Trying resolution ", resolution, sep=''))
  c(mergedClusters, mergedCoexDF) %<-%
  mergeUniformCellsClusters(PBMC_celltypist, clusters = splitClusters,
                            GDIThreshold = resolution,
                            cores = 13,
                            saveObj = TRUE, outDir = OUT_DEFAULT_DIR)
  PBMC_celltypist <- addClusterization(PBMC_celltypist, clName = "merged_celltypist",
                               clusters = mergedClusters,
                               coexDF = mergedCoexDF,
                               override = TRUE)
  mergedClusters <- getClusterizationData(PBMC_celltypist, clName = "merged_celltypist")[[1]]
  num_clusters = nrows(table(mergedClusters))
  cat(paste("Got ", num_clusters, ' clusters', sep=''))
  if (num_clusters == N_CLUSTERS_CELLTYPIST){
    break
  }
  else if (num_clusters < N_CLUSTERS_CELLTYPIST){
    # increase the resolution
    range_lower = resolution
  }
  else{
    # reduce the resolution
    range_upper = resolution
  }
}
```

Save the clustering result

```{r, echo=TRUE, eval=FALSE}
final_clusters = mergedClusters
final_clusters_name = "merged"
cluster = as.data.frame(final_clusters)
colnames(cluster)[colnames(cluster) == deparse(substitute(final_clusters))] <- "cluster"
cluster$cluster = match(cluster$cluster, levels(final_clusters))
cluster$cell = rownames(cluster)
rownames(cluster) = c(1:nrow(cluster))
write_clustering(OUT_CELLTYPIST_DIR, cluster, "cell", "cluster")
```

Differential expression

```{r, echo=TRUE, eval=FALSE}
coexDF <- DEAOnClusters(PBMC_celltypist, clusters = final_clusters)
PBMC_celltypist <- addClusterizationCoex(PBMC_celltypist, clName = final_clusters_name,
                             coexDF = coexDF)
```

```{r, echo=TRUE, eval=FALSE}
saveRDS(PBMC, file = file.path(OUT_CELLTYPIST_DIR, paste0(dataset_name, ".cotan.RDS")))
```

Save markers

```{r, echo=TRUE, eval=FALSE}
write_markers = function(ourDir, clusters, coex, TOP_MARKER_NUM, decreasing) {
    markers = data.frame()

    for (cluster_id in (levels(clusters))) {
        cluster_markers = data.frame()
        pv = coex[, cluster_id]
        names(pv) = rownames(coex)
        sorted_pv = sort(pv, decreasing = decreasing)
        cluster_markers = data.frame(gene = names(sorted_pv)[1:TOP_MARKER_NUM],
                                    cluster = match(cluster_id, levels(clusters)),
                                    rank = 1:TOP_MARKER_NUM)

        markers = rbind(markers, cluster_markers)
    }
    colnames(markers) = c("gene","cluster","rank")

    write.csv(markers, "markers.csv", row.names = FALSE)
}

TOP_MARKER_NUM = 500

numCells <- getNumCells(PBMC_celltypist)
pvals <- pValueFromDEA(coexDF, numCells)

write_markers(OUT_CELLTYPIST_DIR, final_clusters, pvals, TOP_MARKER_NUM, FALSE)
```

Merge clusters according to protein surface

```{r, echo=TRUE, eval=FALSE}
# get barcodes of cells labelled using protein surface
protein_labels = read.csv(paste('../../dataset/', dataset_name, '-Filtered/10x/labels.csv', sep=''))
barcodes_to_keep = protein_labels$cell

barcodes_to_drop = getCells(PBMC)[!getCells(PBMC) %in% barcodes_to_keep]
PBMC_protein <- dropGenesCells(PBMC, cells = barcodes_to_drop)

range_upper = 3
range_lower = 0

repeat{
  resolution = (range_upper + range_lower) / 2
  cat(paste("Trying resolution ", resolution, sep=''))
  c(mergedClusters, mergedCoexDF) %<-%
  mergeUniformCellsClusters(PBMC_protein, clusters = splitClusters,
                            GDIThreshold = resolution,
                            cores = 13,
                            saveObj = TRUE, outDir = OUT_DEFAULT_DIR)
  PBMC_protein <- addClusterization(PBMC_protein, clName = "merged_protein",
                               clusters = mergedClusters,
                               coexDF = mergedCoexDF,
                               override = TRUE)
  mergedClusters <- getClusterizationData(PBMC_protein, clName = "merged_protein")[[1]]
  num_clusters = nrows(table(mergedClusters))
  cat(paste("Got ", num_clusters, ' clusters', sep=''))
  if (num_clusters == N_CLUSTERS_PROTEIN){
    break
  }
  else if (num_clusters < N_CLUSTERS_PROTEIN){
    # increase the resolution
    range_lower = resolution
  }
  else{
    # reduce the resolution
    range_upper = resolution
  }
}
```

Save the clustering result

```{r, echo=TRUE, eval=FALSE}
final_clusters = mergedClusters
final_clusters_name = "merged"
cluster = as.data.frame(final_clusters)
colnames(cluster)[colnames(cluster) == deparse(substitute(final_clusters))] <- "cluster"
cluster$cluster = match(cluster$cluster, levels(final_clusters))
cluster$cell = rownames(cluster)
rownames(cluster) = c(1:nrow(cluster))
write_clustering(OUT_PROTEIN_DIR, cluster, "cell", "cluster")
```

Differential expression

```{r, echo=TRUE, eval=FALSE}
coexDF <- DEAOnClusters(PBMC_protein, clusters = final_clusters)
PBMC_protein <- addClusterizationCoex(PBMC_protein, clName = final_clusters_name,
                             coexDF = coexDF)
```

```{r, echo=TRUE, eval=FALSE}
saveRDS(PBMC, file = file.path(OUT_PROTEIN_DIR, paste0(dataset_name, ".cotan.RDS")))
```

Save markers

```{r, echo=TRUE, eval=FALSE}
write_markers = function(ourDir, clusters, coex, TOP_MARKER_NUM, decreasing) {
    markers = data.frame()

    for (cluster_id in (levels(clusters))) {
        cluster_markers = data.frame()
        pv = coex[, cluster_id]
        names(pv) = rownames(coex)
        sorted_pv = sort(pv, decreasing = decreasing)
        cluster_markers = data.frame(gene = names(sorted_pv)[1:TOP_MARKER_NUM],
                                    cluster = match(cluster_id, levels(clusters)),
                                    rank = 1:TOP_MARKER_NUM)

        markers = rbind(markers, cluster_markers)
    }
    colnames(markers) = c("gene","cluster","rank")

    write.csv(markers, "markers.csv", row.names = FALSE)
}

TOP_MARKER_NUM = 500

numCells <- getNumCells(PBMC_protein)
pvals <- pValueFromDEA(coexDF, numCells)

write_markers(OUT_PROTEIN_DIR, final_clusters, pvals, TOP_MARKER_NUM, FALSE)
```

```{r, echo=TRUE, eval=TRUE}
sessionInfo()
```